/*
 * FILE:        wheel.c
 * AUTHOR:      Artem Mavrin
 * UPDATED:     2016-04-15
 * DESCRIPTION: Implementation of wheels for wheel factorization algorithms.
 */

#include <stdlib.h>
#include "wheel.h"

typedef struct Spoke Spoke;

/*
 * STRUCT:      Wheel
 * DESCRIPTION: A circular singly linked list implementation of wheels used in
 *              wheel factorization algorithms. The wheel is generated by a list
 *              of known primes, called the base primes, and the wheel generates
 *              the sequence of the positive integers which are coprime to each
 *              base prime.
 * FIELDS:      circumference (unsigned long): The product of the base primes.
 *              numSpokes (unsigned long): The number of spokes in the wheel,
 *              which is the number of integers between 1 and circumference
 *              which are coprime to circumference.
 *              primeCandidate (long): The biggest positive integer coprime
 *              to each base prime computed so far.
 *              spoke (Spoke *): Pointer to the next spoke in the wheel.
 */
struct Wheel {
    unsigned long circumference;    /* The product of the base primes */
    unsigned long numSpokes;        /* The number of spokes in the wheel */
    Spoke *spoke;                   /* The next spoke in the wheel */
};

/*
 * STRUCT:      Spoke
 * DESCRIPTION: Container for numbers coprime to the base primes used to create
 *              a wheel.
 * FIELDS:      num (unsigned long): The value represented by this spoke. This
 *              number is coprime to each base prime and it is increased after
 *              every full revolution of the wheel.
 *              next (struct Spoke *): The spoke following the current spoke.
 */
struct Spoke {
    unsigned long num;      /* A number coprime to the base primes */
    struct Spoke *next;     /* The next spoke in the wheel */
};

/*
 * FUNCTION:    newWheel
 * DESCRIPTION: Creates a new wheel for identifying prime number candidates. The
 *              wheel is dynamically allocated and must be deallocated with the
 *              deleteWheel function.
 * PARAMETERS:  basePrimes (const unsigned long *): A list of a few known prime
 *              numbers used to create the wheel (e.g., 2, 3, 5, 7). The numbers
 *              are assumed to be distinct primes, but no check is made to
 *              ensure that they either prime or distinct.
 *              numBasePrimes (const unsigned long): The number of base primes.
 * ERRORS:      If memory could not be allocated for the wheel, a null pointer
 *              is returned.
 * RETURNS:     A pointer to the new wheel.
 */
Wheel * newWheel(const unsigned long *basePrimes,
    const unsigned long numBasePrimes) {
    unsigned long num;    /* To be checked for coprimeness */
    unsigned long index;  /* Used to track position in the base primes list */
    Wheel *wheel;         /* The wheel being created */

    /* Allocate memory for the wheel and check if malloc failed */
    wheel = malloc(sizeof(Wheel));
    if (!wheel)
        return NULL;

    /* Initialize the fields of the wheel */
    wheel->circumference = 1;
    wheel->numSpokes = 0;
    wheel->spoke = NULL;

    /* Compute the circumference (product of base primes) of the wheel */
    for (index = 0; index < numBasePrimes; index++)
        wheel->circumference *= basePrimes[index];

    /* Create all the spokes in the wheel */
    for (num = 1; num < wheel->circumference; num++) {
        /* Check if the current number is coprime to all the base primes */
        int isCoprime = 1;
        for (index = 0; index < numBasePrimes; index++) {
            if (num % basePrimes[index] == 0) {
                isCoprime = 0;
                break;
            }
        }
        if (isCoprime) {
            /* Create a spoke for the current coprime number */
            Spoke *spoke = malloc(sizeof(Spoke));
            /* Delete the wheel and return NULL if malloc failed */
            if (!spoke) {
                deleteWheel(&wheel);
                return NULL;
            }
            /* Assign the current coprime number to this spoke */
            spoke->num = num;
            /* Insert the spoke into the wheel */
            if (!wheel->spoke) {
                /* The current spoke is the first spoke, link it to itself */
                spoke->next = spoke;
            } else {
                /* Link this spoke to the last spoke in the wheel */
                spoke->next = wheel->spoke->next;
                wheel->spoke->next = spoke;
            }
            /* Add the spoke to the end of the wheel */
            wheel->spoke = spoke;
            wheel->numSpokes++;
        }
    }
    /* Go to the first spoke in the wheel */
    wheel->spoke = wheel->spoke->next;

    return wheel;
}

/*
 * FUNCTION:    deleteWheel
 * DESCRIPTION: Deallocates all memory associated with a wheel.
 * PARAMETERS:  wpp (Wheel **): A pointer to a pointer to the wheel being
 *              deleted.
 * RETURNS:     Nothing.
 */
void deleteWheel(Wheel **wpp) {
    if (wpp && *wpp) {
        /* Deallocate all the spokes in the wheel */
        while ((*wpp)->numSpokes-- > 0) {
            Spoke *spoke = (*wpp)->spoke;
            (*wpp)->spoke = (*wpp)->spoke->next;
            free(spoke);
        }
        /* Deallocate the wheel and make the pointer to it NULL */
        free(*wpp);
        *wpp = NULL;
    }
}

/*
 * FUNCTION:    nextp
 * DESCRIPTION: Get the next prime candidate from the wheel. The first prime
 *              candidate is necessarily the smallest prime number not included
 *              in the list of base primes used to create the wheel.
 * PARAMETERS:  wheel (Wheel *): A pointer to the wheel being used.
 * RETURNS:     The next prime candidate computed by the wheel.
 */
unsigned long nextp(Wheel *wheel) {
    wheel->spoke->num += wheel->circumference;    /* Increment current spoke */
    wheel->spoke = wheel->spoke->next;            /* Move to the next spoke */
    return wheel->spoke->num;
}
